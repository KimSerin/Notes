2강. 예제 db설치와 소개, 데이터베이스 관리(만들기/지우기/변경하기)

- 행 + 열 -> 테이블, 테이블 + 테이블 -> 데이터베이스

- 테이블 or database or 프로세저 생성 create
- 테이블 or database or 프로세저 수정 alter
- 테이블 or database or 프로세저 삭제 drop

- sp_helpdb 데이터베이스이름: 데이터베이스의 상세 설명 보여 줌.(특수문자가 있을경우만 [] 사용)

- 테이블이나 데이터베이스 수정하는데 다른데서 사용중인 경우
: alter database [데이터베이스이름] set single_user with rollback immediate


- 데이터베이스 이름 변경
: sp_renamedb NameNow, NameNew

- 데이타베이스 속성에서 파일 크기 변경 가능
(크기를 줄일 때는 alter가 아닌 shrinkfile을 사용, 처음 지정한 크기 이하로는 줄어들지 않는다)

3강. select1 - 기초, 자료형
- 현재 설정되어 있는 데이터베이스가 아닌 경우  생략 불가
ex)
SELECT TOP (1000) [job_id]
      ,[job_desc]
      ,[min_lvl]
      ,[max_lvl]
  FROM [pubs].[dbo].[jobs] //master에 있는 경우 pubs 생략 불가
							//pubs인 경우 dbo까지 생략 가능
							//dbo는 스키마 //db.스키마.테이블
							
- 데이터베이스 설정 명령어
: use [데이터베이스 이름]	//뒤에 go가 필요하지만 자동으로 추가됨(도구>옵션에서 확인)

- 테이블의 컬럼 확인 명령어
: exec sp_help [테이블 이름], exec sp_columns [테이블 이름]

- 컬럼 선택하여 출력
: select [컬럼이름], [컬럼이름]... from [테이블 이름]
컬럼이름에 문자열도 출력 가능
ex)
select 'test' as new_column, [컬럼이름],... from [테이블 이름]
-> new_column이라는 컬럼에 모두 test가 출력
-> 존재하는 컬럼도 as를 사용해서 컬럼명을 다르게 출력할 수 있음
-> as는 생략 가능하지만 쓰는게 좋다

- 변수 선언
: declare @id int, @name char(10) // declare + @ + 변수이름 + 자료형
  set @id = 0	//set으로 변수 초기화
  set @name = '김세린'	//set 여러개여도 생략불가
  select @id, @name

- 도움말 필요시 shift + f1

- char와 varchar의 차이
: char(10)은 대입하는 값의 길이와 상관없이 길이 10으로 할당
  varchar(10)은 대입하는 값의 길이에 따라 길이가 달라짐
ex)   
: declare @c char(10), @v varchar(10)
  set @c = '김세린'
  set @v = '김세린'
  select @c+'추가', @v+'추가'
  -> c는 '김세린     추가' 출력
     v는 '김세린추가' 출력
  주소같은 길이가 다양한 항목은 varchar, 사번같은 길이가 정해진 항목은 char로 설정
  
- 숫자 자료형
: bit(bool, 1비트)
: numeric, decimal(numeric과 같음)(전체자리수, 소수점자리수 설정 가능하지만 용량이 커서 성능에 안좋다)
: 정확한 숫자 표현 시 float이나 real 대신 money 또는 small money 사용 권장
	 
- 문자형
: char, varchar, text(2기가 상당 문자열 저장)

- 바이너리
: binary(hex(바이너리) 값을 저장, 이미지 또는 exe 파일 저장), varbinary(binary기능 + var 기능)

- Unicode character
: nchar, nvarchar, ntext
(national이 붙은 형, 다국어 저장이 가능, 깨지지 않음)
ex)insert into dbo.mytable values (N 'Test data', N'More test data')	//대입 시 n 붙임

- datetime
:.000, .003, .007을 단위로 반올림 되는 것에 주의 
ex) 2019.4.9 13:34:28.999 저장하면 -> 2020.0.0 00:00:00으로 저장 됨
: 2019.4.9, 2019/4/9, 2019-4-9 모두 가능
: set dateformat ymd(년월일 or 월일년 or 일월년 설정 가능)

- 사용자 정의 자료형
: sp_addtype tProdID, 'CHAR(6)'
  sp_addtype tPrice, 'SMALLINT'
  //프로그래밍 기능>사용자정의 데이터 형식에서 확인 가능
  // sp_help '사용자정의 자료형 이름' 또는 그냥 sp_help로 확인
  //CREATE TYPE과 같음(앞으로 사용)
: sp_droptype 타입이름
  //사용자 정의 자료형 삭제
  //DROP TYPE과 같음
 
4강. select2 - 기초, 자료형
- 자료형 바꾸기
: select 1+3	//4
: select 'a'+'b'	//ab
: select 1+'4'	//5 //데이터 형식 우선 순위에 따라 자료형이 바뀜 int>char
: select 'a'+'b'+4	//오류 //데이터 형식 우선 순위에 따라 int>char but a 나 b 는 int로 변환 불가
: select 'a'+'b'+convert(char(1),4)	//암시적 형변환이 불가항 상황이므로 명시적으로 변환 //char 1자리로 변환
: select getdate()+1	//가능, 날짜 하루 더해 짐
: select 10/3	//3
: select 10.0/3	//3.3333
: select 10./3	//3.3333
: select 10/3.	//3.3333
: select convert(decimal(10,8),10)/3	//3.33333333
: substring(자르기), cast(convert와 같음, ansi 사용하는 db면 다 사용가능), left
: floor(절사, 버림), ceiling(절상, 올림), round(반올림)
ex) ROUND(748.58, -1)	//750	//두번째 파라미터가 마이너스인 경우, 소수점 앞에서 반올림	
: replicate(반복), reverse(거꾸로 출력)
: stuff(해당 위치 문자 변경)
ex) stuff('123456', 3, 2, 'abcde')	//12abcde56	//1부터 시작
: replace(해당 문자를 찾아서 변경)(많이씀)
: getdate(현재날짜, 시간), month(getdate())(현재 년도)(==datepart(mm,getdate))
  , year(getdate())+1(내년), day
: convert(varchar(30), getdate(), 9)	// 맨뒤 파라미터 값에 따라 출력 다름
: dateadd(datepart, number, date)	//어떤파트(year or month..)에 몇만큼(number), 어떤날짜에(date) 더할건지
: datediff(d, '76.2.5', getdate())	// 두 날짜의 차이


5강. select3 - where

- 조건
: 숫자인 경우
ex) SELECT id, qty FROM sales WHERE qty>=50
: 문자인 경우
ex) SELECT id, qty FROM sales WHERE id = 'BU1032'
: 날짜인 경우
ex) SELECT ord_date FROM sales WHERE year(ord_date) = 1994(**성능에 나쁨)
: NULL 확인하는 경우 '='로 비교할 수 없다
ex) SELECT id, price FROM title WHERE price IS NULL 또는 IS NOT NULL

- 정렬(**꼭 필요하지 않은 이상 사용하지 않는다. 성능에 좋지 않음)
: ORDER BY [기준 column] (ASC/DESC) 사용하며, 뒤에 방향 생략시 defualt는 ASC
: 기준 column 여러개 사용 가능, 여러개 사용시 asc/desc 각자 설정

- 상위 몇개 출력
: Top [갯수] 사용
ex) SELECT TOP 6 id, qty FROM sales	// ORDER BY 사용안할시 순서 X
     SELECT TOP 6 id, qty FROM sales ORDER BY qty DESC // 가장많이팔린 6개
: TOP [숫자] PERCENT 사용
ex) SELECT TOP 25 PERCENT id, qty FROM sales ORDER BY qty DESC
	// 상위 25 퍼센트 출력

- TOP 사용 시 같은 값이 여러개인 경우?
: WITH TIES 사용
ex) SELECT TOP 6 WITH TIES id, qty FROM sales ORDER BY qty DESC
	// 동점인 경우 6개 이상 출력될 수 있음

- 범위
: BETWEEN [숫자] AND [숫자] 사용
ex) SELECT id, qty FROM sales WHERE qty BETWEEN 10 AND 20 ORDER BY qty

- 목록
: [column] IN (항목, 항목, 항목...) 사용
ex) SELECT id, qty FROM sales WHERE id IN ('BU1032', 'BU1111', 'MC3021')
	// WHERE id = 'BU1032', id = 'BU1111', id = 'MC3021' 와 성능은 같음


- 문자열 포함 찾기
: LIKE + 정규식 사용(ms mql이 허용하는 일부 문법)(** 앞에있는 %는 인덱스를 못쓰게 하여 성능에 아주 안좋다)
ex) ... WHERE title LIKE '%computer%'	// 앞, 뒤에 0개 이상의 문자가 있는, computer를 포함하는 데이터
ex) ... WHERE title LIKE '_computer%'	// computer 앞에 단 1개 문자가 오는 데이터
ex) ... WHERE title LIKE '[a-f][abcde]'	//a부터f 사이 중 하나의 문자 + a,b,c,d,e 중 하나의 문자
ex) ... WHERE title LIKE '[^a-f][^abcde]'	//a부터f 사이가 아닌 문자 + a,b,c,d,e 외의 문자

: PATINDEX('정규포현', '문자열')(문자열에서 패턴에 해당하는 index를 리턴, 없으면 0리턴, 많이 사용 됨)
ex) SELECT PATINDEX('%MI%', 'James Mike')	// 7리턴

- 중복된 행
: DISTINCT 사용
ex) SELECT DISTINCT id FROM sales	// 여러번 팔린 책도 한번씩만 출력
ex) SELECT DISTINCT a, b, c FROM sales	// a,b,c 모두 중복되지 X

**컬럼을 가공하면 성능에 좋지 않다.
ex) WHERE price * 1.1 < 20.00 대신
	WHERE price < 20.00 / 1.1 으로 쓸 것

** ... WHERE year(pubdata) = 1991 성능에 좋지 않음
대신 ... WHERE pubdata BETWEEN '1991.1.1' AND '1991.12.31 23:59:59:998' 로 쓸 것

- OR, AND 연산
: AND가 OR 보다 우선한다
ex) SELECT id, price FROM titles WHERE id LIKE 'BU%' OR id='1389' AND price=19.99
	SELECT id, price FROM titles WHERE id LIKE 'BU%' OR (id='1389' AND price=19.99) 서로 같다
	
6강. 다이어그램, 모델링
- 데이터 베이스에서 다이어그램 생성, foreign키(참조키)가 있다면 자동으로 생성된다.(속성[f4]에서 확인)
- 열쇠 표시가 있는 항목이 primary키
- 테이블 간 연결은 1:다, 또는 1:1 다이어그램 상 열쇠와 무한대 표시로 확인 가능(보통 1:다)
- 테이블 조인할 때, 또는 하위쿼리 만들 때 필요

7강. 테이블 관리1
- 개체의 이름
: 서버.DB.스키마.개체 가 풀네임 (해당 서버, DB에있는 경우 서버, DB, 스키마 생략가능)
- 서버 이름 확인 방법
: sp_helpserver 사용

- 개체 이름에서 지정된 부분만 반환
: PARSENAME('서버.DB.스키마.개체', 번호) AS '출력컬럼이름'
ex) SELECT('localserver.master.dbo.object', 1)	//object
	SELECT('localserver.master.dbo.object', 2)	//dbo
	SELECT('localserver.master.dbo.object', 3)	//master
	SELECT('localserver.master.dbo.object', 4)	//localserver

- 데이터 정렬 목록
: fn_helpcollations()(지원되는 모든 데이터 정렬의 목록 리턴)

- 데이터 정렬 설정
: collate 사용
ex) create table a(
		KorName char(10) collate Korean_Wansung_CI_AS
	,	NKorName char(10) collate Korean_Wansung_CI_AS
	,	usName char(10) collate Latin1_General_CI_AI
)

- 테이블 생성
ex)
CREATE TABLE tempdb.dbo.empl(
	id INT
,	name char(10)
)

- 테이블 변경
ex)
ALTER TABLE sales
	ALTER COLUMN id CHAR(10) NOT NULL
	//자료형 변경 시 잘림 주의
	
- 테이블 삭제
DROP TABLE table_name

- primary키(식별자)	//식별자를 생성하면 인덱스가 만들어진다.
					//sp_helpindex [테이블명] 으로 확인
ex) CREATE TABLE pk_test(
		id INT PRIMARY KEY	//id INT constraint myPK PRIMARY KEY(이름 설정 가능)
	)

- NOT NULL 설정	
ex) CREATE TABLE a(
		id INT NOT NULL
	)

- 테이블 생성 후 primary key 설정
: ALTER TABLE a
	ADD CONSTRAINT [pk이름] PRIMARY KEY (컬럼이름)
	
- 컬럼 추가
: ALTER TABLE [테이블이름]
	ADD dept_id VARCHAR(20) NULL
	
- 컬럼 추가 시 default 설정
ex) ALTER TABLE 사원
	ADD city CHAR(10) NOT NULL DEFAULT '서울'
	//이미 들어가 있는 데이터에 모두 '서울'이 들어감
	//아무 값도 입력하지 않으면 '서울'이 들어감
	
- 테이블이 존재하는 경우만 삭제하도록
if exists (select * from dbo.sysobjects 
where id = object_id(N'[dbo].[테이블이름]') and OBJECTPROPERTY(id, N'IsUserTable') = 1)
drop table [dbo].[테이블이름]
GO	

8강. 테이블 관리2-제약
- 집계함수
ex) SELECT sum(qty) FROM sales	//qty 컬럼 값 모두 더한 값 출력

- max, min
ex) SELECT max(qty) as max, min(qty) as min FROM sales	//qty 컬럼 값의 최대, 최소

- 전체 갯수
: count(컬럼이름) 사용	(**컬럼이름 없이 모든 갯수를 사용하는 것이 성능에 좋다)
ex) SELECT count(*) FROM titles	//모든 컬럼의 갯수
	SELECT count(title_id) FROM titles	
	//title_id의 갯수 출력, NULL값이 있는 경우 카운트 안 됨
	//모든 NULL 값은 집계에서 제외 됨
	
- ISNULL	//NULL인 경우 처리할 때
ex) SELECT ISNULL(3, 1)	//3
	SELECT ISNULL(NULL, 1)	//1
	SELECT price, ISNULL(price, 0) FROM pubs	//price가 null이면 0 출력
	
	
9강. select 4-join, 집계함수
- GROUP BY
ex) SELECT title_id, sum(qty)	//select에는 group by에 온 컬럼 또는 집계함수만 올 수 있음
	FROM sales
	GROUP BY title_id	//title_id로 그룹
	
- GROUP BY 후에 조건 추가 HAVING
ex) SELECT title_id, sum(qty)
	FROM sales
	GROUP BY title_id HAVING sum(qty) >= 30	//group by 없이 having은 존재할 수 없음
	//WHERE 보다 HAVING이 부하가 크다. 가능하면 WHERE 사용
	
- ROLLUP, CUBE
: GROUP BY a,b,c,d라고 가정하면
  a,b,c,d로 묶이는 그룹의 값
  a,b,c로 묶이는 그룹의 소계
  a,b로 묶이는 그룹의 소계
  a로 묶이는 그룹의 소계
  위의 소계들의 총 합계(전체합계)
ex) SELECT type, pub_id, AVG(price)
	FROM titles
	GROUP BY type, pub_id
	WITH ROLLUP

: WITH CUBE a,b,c,d라고 가정하면
  a,b,c,d로 묶이는 그룹의 값
  a,b,c로 묶이는 그룹의 소계
  a,b로 묶이는 그룹의 소계
  a로 묶이는 그룹의 소계
  b,c,d로 묶이는 그룹의 소계
  b,c로 묶이는 그룹의 소계
  b로 묶이는 그룹의 소계
  c,d로 묶이는그룹의 소계
  c로 묶이는 그룹의 소계
  d로 묶이는 그룹의 소계
  위의 소계들의 총 합계(전체합계)
ex) SELECT type, pub_id, AVG(price)
	FROM titles
	GROUP BY type, pub_id
	WITH CUBE

: CUBE는 GROUP BY에 지정된 모든 컬럼 조합에 대한 부분 결과값들을 출력
  ROLLUP은 a에 대한 부분 결과값만을 출력	
  
- GROUPING SETS
ex) SELECT type, pub_id, AVG(price)
	FRPM titles
	GROUP BY type, pub_id	// type + pub_id로 그룹지어 AVG 출력
	
eX) SELECT type, pub_id, AVG(price)
	FROM titles
	GROUP BY GROUPING SETS(type, pub_id) //type별 AVG, pub_id별 AVG
	//GROUP BY GROUPING SETS((type, pub_id), ()) //type + pub_id로 그룹지어 AVG + 전체 평균 출력
	//GROUP BY GROUPING SETS(type, pub_id, ()) //type별 AVG, pub_id별 AVG + 전체 평균

- join
: 정규화된 테이블을 다시 보고서 형태로 모아서 출력할 때 사용
: SELECT * FROM A (INNER) JOIN B ON A.id = B.id		//A∩B
  SELECT * FROM A LEFT (OUTER) JOIN B ON A.id = B.id		//A
  SELECT * FROM A FULL OUTER JOIN B ON A.id = B.id	//A∪B
  SELECT * FROM A RIGHT (OUTER) JOIN B ON A.id = B.id		//B
  SELECT * FROM A LEFT (OUTER) JOIN B ON A.id = B.id WHERE B.id IS NULL	//A-B
  SELECT * FROM A FULL OUTER JOIN B ON A.id = B.id WHERE A.id IS NULL OR B.id IS NULL	//A∪B-A∩B
  SELECT * FROM A RIGHT (OUTER) JOIN B ON A.id = B.id WHERE A.id IS NULL	//B-A
  
: 두 테이블 join 시 각각의 private key 중 하나는 참조키가 된다.

ex)	//현재 사용하지 않는 문법
	SELECT title, price, pub_name
	FROM titles, publishers
	WHERE titles.pub_id = publishers.pub_id
	
	//다음과 같이 써야함
	SELECT title, price, pub_name
	FROM titles		//titles, publishers 순서 상관 X
		JOIN publishers ON titles.pub_id = publishers.pub_id	//INNER 생략
		
	//테이블 3개 join
	SELECT title, pub_name, qty
	FROM publishers
		JOIN titles ON titles.pub_id = publishers.pub_id
		JOIN sales ON sales.title_id = titles.title_id
		
	//alias 별칭 사용
	SELECT title, pub_name, qty
	FROM publishers p
		JOIN titles t ON t.pub_id = p.pub_id
		JOIN sales s ON s.title_id = t.title_id
		
- CROSS JOIN
: 상호 조인이라고도 불림. 한 쪽 테이블의 모든 행들과 다른 테이블의 모든 행을 조인(잘안씀)
ex) SELECT title, price, stor_id
	FROM titles CROSS JOIN sales
	
	//CROSS JOIN과 같음(WHERE 절이 없음, 성능에 좋지 않다)
	SELECT title, price, stor_id
	FROM titles, sales
	
- SELF JOIN
: 원하는 데이터들이 한 테이블에 있을 때 사용(별칭 사용)
ex) 한 책에 여러 작가가 있는 경우
	titleauthor 테이블의 컬럼이 au_id, title_id, au_ord, royaltyper 일 때,
	titld_id 작가1, 작가2 로 출력하려고 함
	SELECT a. title_id, a.au_id, b.au_id
	FROM titleauthor a
		JOIN titleauthor b ON a.title_id = b.title_id
	WHERE a.au_id < b.au_id








	
 
